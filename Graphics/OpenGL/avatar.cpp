// Jason Bricco
// CS4611 - Avatar Assignment
// 12/5/20

#include "libkuhl.h"

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <GL/glew.h>
#include <GLFW/glfw3.h>

static GLuint program = 0; /**< id value for the GLSL program */

static int renderStyle = 0;

static kuhl_geometry* modelgeom  = NULL;
static kuhl_geometry* origingeom = NULL;
static float bbox[6];

static int fitToView = 0;  // was --fit option used?

/** The following variable toggles the display an "origin+axis" marker
 * which draws a small box at the origin and draws lines of length 1
 * on each axis. Depending on which matrices are applied to the
 * marker, the marker will be in object, world, etc coordinates. */
static int showOrigin = 0; // was --origin option used?

/** Initial position of the camera. 1.55 is a good approximate
 * eyeheight in meters.*/
static const float initCamPos[3] = { 0.0f, 1.55f, -4.0f};

/** A point that the camera should initially be looking at. If
 * fitToView is set, this will also be the position that model will be
 * translated to. */
static const float initCamLook[3] = { 0.0f, 0.0f, -5.0f};

/** A vector indicating which direction is up. */
static const float initCamUp[3] = { 0.0f, 1.0f, 0.0f };

#define GLSL_VERT_FILE "avatar.vert"
#define GLSL_FRAG_FILE "avatar.frag"

/* Called by GLFW whenever a key is pressed. */
void keyboard(GLFWwindow* window, int key, int scancode, int action, int mods)
{
	/* If the library handles this keypress, return */
	if (kuhl_keyboard_handler(window, key, scancode, action, mods))
		return;

	if(action != GLFW_PRESS)
		return;
	
	switch(key)
	{
		case GLFW_KEY_R:
		{
			// Reload GLSL program from disk
			kuhl_delete_program(program);
			program = kuhl_create_program(GLSL_VERT_FILE, GLSL_FRAG_FILE);

			/* Apply the program to the model geometry */
			kuhl_geometry_program(modelgeom, program, KG_FULL_LIST);
		} break;

		// Toggle different sections of the GLSL fragment shader
		case GLFW_KEY_SPACE:
		case GLFW_KEY_PERIOD:
		{
			// Cycle through the 6 relevant render styles.
			renderStyle++;

			if (renderStyle > 6)
				renderStyle = 0;

			switch (renderStyle)
			{
				case 0: printf("Render style 0: Diffuse (no color)\n"); break;
				case 1: printf("Render style 1: Diffuse + normalmap (no color)\n"); break;
				case 2: printf("Render style 2: Normals as color\n"); break;
				case 3: printf("Render style 3: Normals as color (normalmap)\n"); break;
				case 4: printf("Render style 4: Diffuse + color with original normals.\n"); break;
				case 5: printf("Render style 5: Diffuse + color with adjusted normals.\n"); break;
				case 6: printf("Render style 6: Diffuse + color + specular with adjusted normals.\n"); break;
			}
		} break;
	}
}

/** Given a bounding box (bbox) calculate a matrix that places the
 * bounding box on top of the specified location. "On top" means that
 * if you specify 0,0,0, then the model will be scaled to fit into a
 * 1x1x1 box whose center is at (0,0.5,0). The bbox variable is
 * usually generated by kuhl_load_model(). */
void get_fit_matrix(float result[16], float xPos, float yPos, float zPos, float bbox[6])
{
	/* Get a matrix to scale+translate the model based on the bounding
	 * box. If the last parameter is 1, the fit matrix will cause the
	 * bounding box to sit at the origin on top of the XZ plane. If it
	 * is set to 0, the fit matrix will cause the bounding box to be
	 * centered at 0,0,0. */
	float fitMat[16];
	kuhl_bbox_fit(fitMat, bbox, 1);

	/* Translate the model from the origin to the requested location. */
	float transMat[16];
	mat4f_translate_new(transMat, xPos, yPos, zPos);

	/* The final matrix will be one which first fits the box on top of
	   the origin, then moves the model to the requested location. */
	mat4f_mult_mat4f_new(result, transMat, fitMat);
	return;
}

/** Draws the 3D scene. */
void display()
{	
	/* Ensure the slaves use the same render style as the master
	 * process. */
	dgr_setget("style", &renderStyle, sizeof(int));
	
	/* Render the scene once for each viewport. Frequently one
	 * viewport will fill the entire screen. However, this loop will
	 * run twice for HMDs (once for the left eye and once for the
	 * right). */
	viewmat_begin_frame();

	for(int viewportID=0; viewportID<viewmat_num_viewports(); viewportID++)
	{
		viewmat_begin_eye(viewportID);

		/* Where is the viewport that we are drawing onto and what is its size? */
		int viewport[4]; // x,y of lower left corner, width, height
		viewmat_get_viewport(viewport, viewportID);

		/* Tell OpenGL the area of the window that we will be drawing in. */
		glViewport(viewport[0], viewport[1], viewport[2], viewport[3]);

		/* Clear the current viewport. Without glScissor(), glClear()
		 * clears the entire screen. We could call glClear() before
		 * this viewport loop---but in order for all variations of
		 * this code to work (Oculus support, etc), we can only draw
		 * after viewmat_begin_eye(). */
		glScissor(viewport[0], viewport[1], viewport[2], viewport[3]);
		glEnable(GL_SCISSOR_TEST);
		glClearColor(.2f,.2f,.2f,0.0f); // set clear color to grey
		glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
		glDisable(GL_SCISSOR_TEST);
		glEnable(GL_DEPTH_TEST); // turn on depth testing
		kuhl_errorcheck();

		/* Turn on blending (note, if you are using transparent textures,
		   the transparency may not look correct unless you draw further
		   items before closer items.). */
		glEnable(GL_BLEND);
		glBlendEquationSeparate(GL_FUNC_ADD, GL_FUNC_ADD);
		glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ZERO);

		/* Get the view or camera matrix; update the frustum values if needed. */
		float viewMat[16], perspective[16];
		viewmat_get(viewMat, perspective, viewportID);

		glUseProgram(program);
		kuhl_errorcheck();

		/* Send the perspective projection matrix to the vertex program. */
		glUniformMatrix4fv(kuhl_get_uniform("Projection"),
		                   1, // number of 4x4 float matrices
		                   0, // transpose
		                   perspective); // value

		float fitMat[16];

		if (fitToView)
			get_fit_matrix(fitMat, initCamLook[0], initCamLook[1], initCamLook[2], bbox);
		else mat4f_identity(fitMat);
		
		float modelview[16];
		mat4f_mult_mat4f_new(modelview, viewMat, fitMat); // modelview = view * model

		/* Send the modelview matrix to the vertex program. */
		glUniformMatrix4fv(kuhl_get_uniform("ModelView"),
		                   1, // number of 4x4 float matrices
		                   0, // transpose
		                   modelview); // value

		glUniform1i(kuhl_get_uniform("renderStyle"), renderStyle);

		kuhl_errorcheck();
		kuhl_geometry_draw(modelgeom); /* Draw the model */
		kuhl_errorcheck();

		if(showOrigin && origingeom != NULL)
		{
			/* Save current line width */
			GLfloat origLineWidth;
			glGetFloatv(GL_LINE_WIDTH, &origLineWidth);
			GLfloat lineWidthRange[2] = { -1.0f, -1.0f };
			glGetFloatv(GL_SMOOTH_LINE_WIDTH_RANGE, lineWidthRange);

			if(lineWidthRange[1] > 4)
				glLineWidth(4); // make lines thick
			else
				glLineWidth(lineWidthRange[1]);

			/* Object coordinate system origin */
			kuhl_geometry_draw(origingeom); /* Draw the origin marker */

			/* World coordinate origin */
			mat4f_copy(modelview, viewMat);

			glUniformMatrix4fv(kuhl_get_uniform("ModelView"),
			                   1, // number of 4x4 float matrices
			                   0, // transpose
			                   modelview); // value
			kuhl_geometry_draw(origingeom); /* Draw the origin marker */
			
			/* Restore line width */
			glLineWidth(origLineWidth);
		}

		// aspect ratio will be zero when the program starts (and FPS hasn't been computed yet)
		if(dgr_is_master())
		{
			float stretchLabel[16];
			mat4f_scale_new(stretchLabel, 1/8.0f / viewmat_window_aspect_ratio(), 1/8.0f, 1.0f);
			
			/* Position label in the upper left corner of the screen */
			float transLabel[16];
			mat4f_translate_new(transLabel, -.9f, .8f, 0.0f);
			mat4f_mult_mat4f_new(modelview, transLabel, stretchLabel);
			glUniformMatrix4fv(kuhl_get_uniform("ModelView"), 1, 0, modelview);

			/* Make sure we don't use a projection matrix */
			float identity[16];
			mat4f_identity(identity);
			glUniformMatrix4fv(kuhl_get_uniform("Projection"), 1, 0, identity);
		}

		glUseProgram(0); // stop using a GLSL program.
		viewmat_end_eye(viewportID);
	} // finish viewport loop

	/* Update the model for the next frame based on the time. We
	 * convert the time to seconds and then use mod to cause the
	 * animation to repeat. */
	double time = glfwGetTime();
	dgr_setget("time", &time, sizeof(double));
	kuhl_update_model(modelgeom, 0, fmodf((float)time,10.0f));
	
	viewmat_end_frame();

	/* Check for errors. If there are errors, consider adding more
	 * calls to kuhl_errorcheck() in your code. */
	kuhl_errorcheck();
}

int main(int argc, char** argv)
{
	/* Initialize GLFW and GLEW */
	kuhl_ogl_init(&argc, argv, 512, 512, 32, 4);
	
	char* modelFilename = NULL;
	char* modelTexturePath = NULL;

	int currentArgIndex = 1; // skip program name
	int usageError = 0;

	while (argc > currentArgIndex)
	{
		if (strcmp(argv[currentArgIndex], "--fit") == 0)
			fitToView = 1;
		else if(strcmp(argv[currentArgIndex], "--origin") == 0)
			showOrigin = 1;
		else if (modelFilename == NULL)
		{
			modelFilename = argv[currentArgIndex];
			modelTexturePath = NULL;
		}
		else if (modelTexturePath == NULL)
			modelTexturePath = argv[currentArgIndex];
		else usageError = 1;
		
		currentArgIndex++;
	}

	// If we have no model to load or if there were too many arguments.
	if(modelFilename == NULL || usageError)
	{
		printf("Usage:\n"
		       "%s [--fit] [--origin] modelFile     - Textures are assumed to be in the same directory as the model.\n"
		       "- or -\n"
		       "%s [--fit] [--origin] modelFile texturePath\n"
		       "If the optional --fit parameter is included, the model will be scaled and translated to fit within the approximate view of the camera\n"
		       "If the optional --origin parameter is included, a box will is drawn at the origin and unit-length lines are drawn down each axis.\n",
		       argv[0], argv[0]);

		exit(EXIT_FAILURE);
	}

	/* Specify function to call when keys are pressed. */
	glfwSetKeyCallback(kuhl_get_window(), keyboard);

	/* Compile and link a GLSL program composed of a vertex shader and
	 * a fragment shader. */
	program = kuhl_create_program(GLSL_VERT_FILE, GLSL_FRAG_FILE);

	dgr_init();     /* Initialize DGR based on environment variables. */

	viewmat_init(initCamPos, initCamLook, initCamUp);

	// Clear the screen while things might be loading
	glClearColor(0.2f, 0.2f, 0.2f, 1.0f);
	glClear(GL_COLOR_BUFFER_BIT);

	// Load the model from the file
	modelgeom = kuhl_load_model(modelFilename, modelTexturePath, program, bbox);

	if (showOrigin)
		origingeom = kuhl_load_model("../models/origin/origin.obj", modelTexturePath, program, NULL);

	while (!glfwWindowShouldClose(kuhl_get_window()))
	{
		display();
		kuhl_errorcheck();

		/* process events (keyboard, mouse, etc) */
		glfwPollEvents();
	}

	exit(EXIT_SUCCESS);
}
